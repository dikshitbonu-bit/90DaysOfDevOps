PART 1A: CORE LINUX DIRECTORIES (MUST KNOW)

/ (root)
This is the starting point of the Linux file system. Every file, directory, and device ultimately exists under root. When I’m trying to understand the overall structure of a system or verify what exists on a server, this is where i would look for.
I would use this when I want a bird’s-eye view of the system.

/home
This directory contains home folders for normal users. Each user gets their own space here for files, scripts, downloads, and personal configuration files.
I would use this when dealing with user-specific data or debugging issues related to a particular user.

/root
This is the home directory of the root (administrator) user, not the same as /. It contains root-specific configuration files and scripts.
I would use this when performing administrative tasks as the root user.

/etc
This directory stores system-wide configuration files. Almost every service reads its configuration from here, including SSH, networking, and cron.
I would use this when configuring or troubleshooting services and system settings.

/var/log
This directory holds log files generated by the system and applications. Logs tell you what actually happened and are critical for debugging.
I would use this when investigating errors, service failures, crashes, or unexpected behavior.

/tmp
This directory is used for temporary files created by applications. Files here are short-lived and often removed after reboot.
I would use this for temporary testing, downloads, or scratch files that don’t need to persist.

PART 1B: ADDITIONAL DIRECTORIES (GOOD TO KNOW)

/bin
This directory contains essential command binaries needed for basic system operation, especially during boot or recovery.
I would use this when the system is in a minimal or broken state and only core commands are available.

/usr/bin
This directory contains most user-level commands and utilities. The majority of everyday tools live here.
I would use this for normal daily operations like development, scripting, and troubleshooting.

/opt
This directory is used for optional or third-party software that is not managed directly by the system package manager.
I would use this when installing vendor software or custom applications manually.


CENARIO 1: SERVICE NOT STARTING

Problem:
A web application service called myapp failed to start after a server reboot.

Step 1: Check the service status
Command: systemctl status myapp
Why: This shows whether the service is running, failed, inactive, or not found, and usually gives the first error hint.

Step 2: Check recent logs for the service
Command: journalctl -u myapp -n 50
Why: Logs explain why the service failed, such as config errors, missing files, or permission issues.

Step 3: Check if the service is enabled on boot
Command: systemctl is-enabled myapp
Why: This tells whether the service is configured to start automatically after a reboot.

Step 4: Try restarting the service
Command: systemctl restart myapp
Why: After inspecting logs and status, restarting verifies whether the issue is temporary or persistent.

Step 5: Re-check service status
Command: systemctl status myapp
Why: Confirms whether the restart succeeded or the service failed again.

What I learned:
Always check the service status first, read logs before taking action, and confirm whether the service is enabled to start on boot. Never restart blindly without looking at logs.


SCENARIO 2: HIGH CPU USAGE

Problem:
The application server is slow and users are complaining about performance.

Step 1: Check live CPU usage
Command: top
Why: This shows real-time CPU usage and immediately reveals if the system is under heavy load and which processes are consuming CPU.

Step 2: Identify the highest CPU-consuming processes
Command: ps aux --sort=-%cpu | head -10
Why: This lists processes sorted by CPU usage so you can clearly see which process is causing the spike.

Step 3: Note the process ID (PID) of the top process
Command: ps -p <PID> -o pid,cmd,%cpu,%mem
Why: This provides detailed information about the specific process using high CPU, helping decide whether it is expected or abnormal.

Step 4: Check if the process belongs to a service
Command: systemctl status <service-name>
Why: Many high-CPU processes are managed by services, and checking the service gives context and control options.

Step 5: Decide the action
Possible actions include restarting the service, scaling resources, or fixing application logic.
Why: Action should be based on understanding, not panic.

What I learned:
Always identify the process first before taking action. High CPU is a symptom, not the root cause.


SCENARIO 3: FINDING SERVICE LOGS

Problem:
A developer asks: “Where are the logs for the docker service?”
The service is managed by systemd.

Step 1: Check the service status
Command: systemctl status docker
Why: Confirms the service name, current state, and often shows recent log lines.

Step 2: View recent logs for the service
Command: journalctl -u docker -n 50
Why: Displays the last 50 log entries related to the Docker service, helping identify errors or warnings.

Step 3: Follow logs in real time
Command: journalctl -u docker -f
Why: Allows you to watch logs live while reproducing the issue, similar to tailing a log file.

Step 4: Identify time-based issues if needed
Command: journalctl -u docker --since "10 minutes ago"
Why: Helps narrow logs to the time window when the issue occurred.

What I learned:
For systemd-managed services, logs are stored in journald and accessed using journalctl, not always in plain files under /var/log.


SCENARIO 4: FILE PERMISSION ISSUE

Problem:
A script at /home/user/backup.sh is not executing.
Running ./backup.sh returns “Permission denied”.

Step 1: Check current file permissions
Command: ls -l /home/user/backup.sh
Why: Shows read, write, and execute permissions and confirms whether the file is executable.

Step 2: Add execute permission
Command: chmod +x /home/user/backup.sh
Why: Scripts require execute (x) permission to run.

Step 3: Verify permissions
Command: ls -l /home/user/backup.sh
Why: Confirms that execute permission was successfully added.

Step 4: Run the script again
Command: ./backup.sh
Why: Validates that the issue is fixed.

What I learned:
“Permission denied” usually means the execute bit is missing, not that the script itself is broken.

